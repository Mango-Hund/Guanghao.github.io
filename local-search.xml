<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux基础知识（二）</title>
    <link href="/2020/01/15/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/01/15/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="用户-和-权限-的基本概念"><a href="#用户-和-权限-的基本概念" class="headerlink" title="用户 和 权限 的基本概念"></a>用户 和 权限 的基本概念</h3><p>基本概念：<br>用户是在Linux系统工作中重要的一环，用户管理包括用户 和组管理<br>在Linux系统中，不论是由本机或是远程登录系统，每个系统都必须要有一个账号，并且对于不同的系统资源拥有不同的使用权限<br>在Linux中，可以指定每一个用户 针对 不同的文件和目录 的 不同权限<br>对 文件和目录的权限包括：<br><img src="/img/linux/20.png" srcset="/img/loading.gif" alt="图20"> </p><h4 id="组"><a href="#组" class="headerlink" title="组"></a>组</h4><p>为了方便用户管理，提出了组的概念，在实际应用中，可以针对组设置好权限，然后将不同的用户添加 到对应的组中，从而不用依次为每一个用户设置权限<br><img src="/img/linux/21.png" srcset="/img/loading.gif" alt="图21"></p><h4 id="ls-l扩展"><a href="#ls-l扩展" class="headerlink" title="ls-l扩展"></a>ls-l扩展</h4><p><img src="/img/linux/22.png" srcset="/img/loading.gif" alt="图22"><br>ls-l可以查看文件夹下文件的详细信息，从左到右依次是：<br>权限，读一个字符如果是d 表示目录<br>硬链接数 通俗地讲，就是有多少钟方式，可以访问当前的目录/文件<br>拥有者，家目录下 文件/目录的拥有者通常都是当前用户<br>组，在Linux中，很多时候，会出现组名和用户名相同的情况<br>大小<br>时间<br>名称<br><img src="/img/linux/23.png" srcset="/img/loading.gif" alt="图23"></p><h4 id="chmod简单使用（重要）"><a href="#chmod简单使用（重要）" class="headerlink" title="chmod简单使用（重要）"></a>chmod简单使用（重要）</h4><p>chmod可以修改 用户/组 对 文件/目录的权限<br>命令格式如下：<br><code>chmod +/- rwx 文件名|目录名</code>  </p><h4 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h4><p>Linux系统中root账号通常用于系统的维护和管理，对操作系统的所有资源 具有所有访问权限<br>在大多数版本的linux中，都不推荐直接使用root账号登录系统<br>在Linux安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为标准用<code>sudo</code><br>su是 substitute user 的缩写，表示使用另一个用户的身份<br>sudo命令用来以其他身份来执行命令，预设的身份是 root<br>用户使用sudo时，必须先输入密码。之后会有5分钟的有效期限，超过期限必须重新输入密码  </p><h4 id="组管理-终端命令"><a href="#组管理-终端命令" class="headerlink" title="组管理 终端命令"></a>组管理 终端命令</h4><p>创建组/删除组的终端命令都需要通过sudo来执行<br><img src="/img/linux/24.png" srcset="/img/loading.gif" alt="图24">  </p><h4 id="用户管理-终端命令"><a href="#用户管理-终端命令" class="headerlink" title="用户管理 终端命令"></a>用户管理 终端命令</h4><p><img src="/img/linux/25.png" srcset="/img/loading.gif" alt="图25"><br>创建用户时，如果忘记添加-m选项指定新用户的家目录—最简单的方法就是删除用户，重新创建<br>创建用户时，默认会创建一个和用户名同名的组名<br>用户信息保存在/etc/passwd文件中  </p><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><p><img src="/img/linux/26.png" srcset="/img/loading.gif" alt="图26"><br>passwd文件<br>/etc/passwd文件存放的时用户的信息，由6个分号组成的7个信息，分别是  </p><ol><li>用户名</li><li>密码（x. 表示加密的密码）</li><li>UID（用户标识）</li><li>GID（组标识）</li><li>用户全名或本地账号</li><li>家目录</li><li>登录使用的Schell，就是登录之后，使用的终端命令，Ubuntu默认是dash  </li></ol><p>usermod<br>usermod可以来设置用户的主组/附加组 和登录Shell 命令格式下：<br>主组：通常在新建用户指定，在etc/passwd的第四列GID对应的组<br>附加组：在etc/group中最后一列表示该组的用户列表，用于指定用户的附加权限<br>（设置了用户的附加组之后，需要重新登录才能生效）<br><img src="/img/linux/27.png" srcset="/img/loading.gif" alt="图27"><br>（默认使用useradd添加的用户是没有权限使用sudo以及root身份执行命令的，可以使用以下命令，将用户添加到sudo附加组中）<br><code>usermod -G sudo 用户名</code></p><p>which（重要）<br>提示<br><code>/etc/passwd</code> 是用于保存用户信息的文件<br><code>/usr/bin/passwd</code> 是用于修改用户密码的程序<br><code>which</code>命令可以查看执行命令的位置  </p><h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p><img src="/img/linux/28.png" srcset="/img/loading.gif" alt="图28"><br>su 不接用户名，可以切换到root。但是不推荐使用，因为不安全<br>exit示意图如下：<br><img src="/img/linux/29.png" srcset="/img/loading.gif" alt="图29">  </p><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p><img src="/img/linux/30.png" srcset="/img/loading.gif" alt="图30"><br>命令的格式如下：<br><img src="/img/linux/31.png" srcset="/img/loading.gif" alt="图31"><br>hmod在设置权限的时候，可以简单的使用三个数字分别对应拥有者/组和其他 用户的权限<br>直接修改文件|目录 读【写】执行权限，但是不能精确到拥有者【组】其他chmod +/-rwx 文件名|目录名<br><img src="/img/linux/32.png" srcset="/img/loading.gif" alt="图32"></p><h3 id="系统信息相关命令"><a href="#系统信息相关命令" class="headerlink" title="系统信息相关命令"></a>系统信息相关命令</h3><p><img src="/img/linux/33.png" srcset="/img/loading.gif" alt="图33"><br>本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 系统日期和时间/磁盘空间占用情况/程序执行情况<br>本小节学习的终端命令基本都是查询命令，通过这些命令对系统资源的使用情况有个了解  </p><h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p><img src="/img/linux/34.png" srcset="/img/loading.gif" alt="图34"></p><h4 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h4><p><img src="/img/linux/35.png" srcset="/img/loading.gif" alt="图35"><br><code>-h</code>以人性化方式显示文件大小  </p><h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><p>所谓进程就是 通俗地说就是 当前正在执行的一个程序<br>默认只会显示当前用户通过终端启动的应用程序<br>ps选项说明功能<br><img src="/img/linux/36.png" srcset="/img/loading.gif" alt="图36"><br>使用kill命令的时候，最好只终止当前用户开启的进程，而不要终止root身份开启的进程<br>否则可能导致系统崩溃<br>要推出top 输入一个q即可  </p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>目标：<br>查找文件：<code>find</code><br>软链接：<code>ln</code><br>打包和压缩： <code>tar</code><br>软件安装：<code>apt-get</code></p><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><p>find命令功能非常强大，通常用来在 特定目录下 搜索 符合条件的文件<br><code>find 【路径】 - name “*.py”</code> 查找指定路径下扩展名是 .py 的文件，包括子目录  </p><ul><li>如果省略路径，表示在当前文件夹下查找</li><li>之前学习的通配符，在使用find命令时同时使用</li></ul><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p><code>ln -s</code> 被链接的源文件  链接文件<br>建立文件的软链接，用通俗的方式讲类似于 Windows下的快捷方式<br>注意：<br>没有 -s选项建立的是一个硬链接文件，两个文件占用相同大小的硬盘空间，工作中机会不会建立文件的硬链接<br>源文件要使用绝对路径，不能使用相对路径，这样方便移动链接文件后，仍能够正常使用  </p><p>硬链接<br>在Linux中，文件名和文件数据是分开存储的<br><img src="/img/linux/37.png" srcset="/img/loading.gif" alt="图37"><br>在linux中，只有文件的硬链接数==0才会被删除<br>使用ls -l可以查看一个文件的硬链接的数量   </p><h4 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h4><p>打包压缩是日常工作中备份文件的一种方式在不同的操作系统中，常用的打包方式是不同的<br>windows 常用rar<br>mac常用 zip<br>linux常用tar.gz<br>打包/解包<br>tar是Linux中常用的备份工具，此命令可以把一系列文件打包到一个大文件中，也可以把一个打包的大文件恢复成一系列文件<br>tar的命令格式如下：  </p><h1 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h1><p><code>tar -cvf 打包文件.tar 被打包文件/路径....</code>  </p><h1 id="解包文件"><a href="#解包文件" class="headerlink" title="解包文件"></a>解包文件</h1><p><code>tar -xvf 打包文件.tar</code><br><img src="/img/linux/38.png" srcset="/img/loading.gif" alt="图38">  </p><ol><li>压缩/解压缩<br>tar与gzip命令结合可以实现文件的打包和压缩<br>tar只负责打包，但不压缩<br>用gzip压缩tar打包后的文件，其扩展名一般用xxx.tar.gz<br>在Linux中，最常见的压缩文件格式就是xxx.tar.gz<br>在tar命令中，有一个-z的选项可以调用gzip。从而方便的实现压缩和解压缩的功能<br><img src="/img/linux/39.png" srcset="/img/loading.gif" alt="图38"><br>C 解压缩到指定的路径，要解压缩的目录必须存在 </li><li>bzip2<br>tar和bzip2命令结合使用同样可以打包和压缩，其扩展名为xxx.tar.bz2<br>在tar命令中有个选项-j可以调用bzip2，从而可以方便的实现压缩和解压缩的功能<br><img src="/img/linux/40.png" srcset="/img/loading.gif" alt="图40"></li></ol><h4 id="通过apt安装-卸载-更新软件包"><a href="#通过apt安装-卸载-更新软件包" class="headerlink" title="通过apt安装/卸载/更新软件包"></a>通过apt安装/卸载/更新软件包</h4><p>apt是Advanced Packaging Tool, 是<br><img src="/img/linux/41.png" srcset="/img/loading.gif" alt="图41"></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识（一）</title>
    <link href="/2020/01/10/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/01/10/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>内核（kernel）是系统的心脏，是运行程序和管理像磁盘和打印机登硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。</p><h3 id="Linux文件和目录结构"><a href="#Linux文件和目录结构" class="headerlink" title="Linux文件和目录结构"></a>Linux文件和目录结构</h3><ul><li><p><code>/：</code>根目录，一般根目录下只存放目录，在linux下有且只有一个根目录，所有的东西都是从这里开始的。当在终端里输入/home﻿​，其实是在告诉电脑，先从/（根目录）开始，再进入home目录  </p></li><li><p><code>/bin、/usr/bin</code>: 可执行二进制文件的目录，如常用的命令<code>ls 、tar、mv、cat</code>等  </p></li><li><p><code>/dev</code>:  放置linux下的设备文件，访问该目录下的某个文件，相当于访问某个设备，常用的是挂载光驱<code>mount/dev/cdrom/mnt</code> </p></li><li><p><code>/boot</code>: 放置linux系统启动时用的一些文件，如linux的内核文件:<code>/boot/vmlinuz</code>，系统引导管理器：<code>/boot/grub</code></p></li><li><p><code>/etc</code>: 系统配置文件存放的目录, 不建议在此目录存放可执行文件</p></li><li><p><code>/home</code>: 系统默认的用户家目录,新增用户账号时, 用户的家目录都存放此目录下  </p></li><li><p><code>/lib、/usr/lib、/usr/local/lib</code>: 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助 </p></li><li><p><code>/lost*fount</code>: 系统产生错误时，会将一些遗失的片段放置于此目录下  </p></li><li><p><code>/mnt: /media</code>: 光盘默认挂载点，通常将光盘挂载于/mnt/cdrom下，也可以选择任意位置挂载  </p></li><li><p><code>/opt</code>: 给主机额外安装软件所摆放的目录  </p></li><li><p><code>/proc</code>: 此目录的数据都在内存中，如系统核心、外部设备、网络状态，由于数据都存放在内存中，所以不占用磁盘空间，比较重要的文件有<code>/proc/cpuinfo、/proc/dma、/proc/net/</code>等  </p></li><li><p><code>/root</code>: 系统管理员root的家目录  </p></li></ul><p>在职场中，大量的服务器维护工作都是在远程 通过ssh客户端来完成的，并没有图形界面、所有的维护工作都需要命令来完成</p><p>小技巧：<br><code>ctrl + shift + =</code> 放大终端窗口的字体显示<br><code>ctrl + -</code>  缩小终端窗口中的字体显示</p><h3 id="常用的Linux指令"><a href="#常用的Linux指令" class="headerlink" title="常用的Linux指令"></a>常用的Linux指令</h3><p><img src="/img/linux/01.png" srcset="/img/loading.gif" alt="图1"></p><p>自动补全<br>在敲出文件/目录/命令 等等，可以<code>tab</code>补全</p><p>inux终端命令格式<br><code>command [-option] [parameter]</code></p><p>查阅命令帮助信息（知道）</p><ol><li><code>help  command --help</code> </li><li><code>man man command</code><br><img src="/img/linux/02.png" srcset="/img/loading.gif" alt="图2"></li></ol><p>Linux下文件或者目录名称最长可以有256个字符<br>以.开头的文件为隐藏文件，需要用-a 参数才能显示<br><code>.</code>代表当前目录<br><code>..</code>代表上一级目录 </p><h4 id="ls的详细介绍"><a href="#ls的详细介绍" class="headerlink" title="ls的详细介绍"></a>ls的详细介绍</h4><p>ls列出目录下的内容，选项如下<br><img src="/img/linux/03.png" srcset="/img/loading.gif" alt="图3"></p><p>ls通配符的使用<br><img src="/img/linux/04.png" srcset="/img/loading.gif" alt="图4"></p><h4 id="cd的详细介绍"><a href="#cd的详细介绍" class="headerlink" title="cd的详细介绍"></a>cd的详细介绍</h4><p>cd是英文单词change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一<br>注意： linux所有的目录和文件名都是大小写敏感的<br><img src="/img/linux/05.png" srcset="/img/loading.gif" alt="图5"><br>（~波浪号代表用户家目录）</p><p>相对路径：在输入路径时，最前面不是/或者~，表示相对当前目录 所在的目录位置<br>绝对路劲：在输入路径时，最前面是/或者~，表示 根目录/家目录开始的具体目录位置</p><h4 id="touch的详细介绍"><a href="#touch的详细介绍" class="headerlink" title="touch的详细介绍"></a>touch的详细介绍</h4><p>创建文件或者修改文件时间<br>-如果文件不存在，可以创建一个空白文件<br>-如果文件已经存在，可以修改文件的末次修改日期  </p><h4 id="mkdir的详细介绍"><a href="#mkdir的详细介绍" class="headerlink" title="mkdir的详细介绍"></a>mkdir的详细介绍</h4><p>创建一个新的目录<br><code>-p</code>可以递归创建目录<br>新建目录的名称 不能与当前目录中 已有的目录或文件 同名 </p><h4 id="rm的详细介绍"><a href="#rm的详细介绍" class="headerlink" title="rm的详细介绍"></a>rm的详细介绍</h4><p>删除文件或目录<br>使用rm命令要小心，因为文件删除后不能恢复<br>选项<br><code>-f</code>强制删除，忽略不存在的文件，无需提示<br><code>-r</code> 递归地删除目录下的内容，删除文件夹时必须加此参数</p><h4 id="拷贝和移动文件"><a href="#拷贝和移动文件" class="headerlink" title="拷贝和移动文件"></a>拷贝和移动文件</h4><p><img src="/img/linux/06.png" srcset="/img/loading.gif" alt="图6"></p><h5 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h5><p>tree命令可以树状图列出文件目录结构<br>选项<br><code>-d</code>  只显示目录  </p><h5 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h5><p>p命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS底下的copy命令<br><img src="/img/linux/07.png" srcset="/img/loading.gif" alt="图7"><br>cp 复制文件路径即文件  目标文件</p><h5 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h5><p><code>mv</code> 源文件 目标文件<br><code>-i</code> 覆盖文件前提示<br>可以起到重命名的作用<br><img src="/img/linux/08.png" srcset="/img/loading.gif" alt="图8"></p><h4 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h4><p><img src="/img/linux/09.png" srcset="/img/loading.gif" alt="图9"></p><h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><p><code>cat</code> 命令可以用来查看文件内容、创建文件、文件合并、追加文件内容等功能<br><code>cat</code> 会一次显示所有的内容，适合查看内容较少的文本文件  </p><h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><p>more命令可以用于分屏显示文件内容，每次只显示一页内容<br>适合查看内容较多的文本文件<br>使用more的操作键<br>空格键  显示手册页的下一屏<br><img src="/img/linux/10.png" srcset="/img/loading.gif" alt="图10"></p><h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5><p>Linux系统中<code>grep</code>命令是一种强大的文本搜索工具<br><code>grep</code>允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式<br><img src="/img/linux/11.png" srcset="/img/loading.gif" alt="图11"><br><img src="/img/linux/12.png" srcset="/img/loading.gif" alt="图12"><br>常用的两种模式查找<br><img src="/img/linux/13.png" srcset="/img/loading.gif" alt="图13"></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="echo-文字内容"><a href="#echo-文字内容" class="headerlink" title="echo 文字内容"></a><code>echo</code> 文字内容</h5><p><code>echo</code>会在终端中显示参数指定的文字，通常会和 重定向联合使用  </p><h5 id="重定向-gt-和-gt-gt"><a href="#重定向-gt-和-gt-gt" class="headerlink" title="重定向&gt;和&gt;&gt;"></a>重定向<code>&gt;</code>和<code>&gt;&gt;</code></h5><p><code>Linux</code>允许将命令执行结果，重定向到一个文件<br>将本应显示在终端上的内容输出/追加到指定文件中<br>其中<br><code>&gt;</code>表示输出，会覆盖文件原有的内容<br><code>&gt;&gt;</code>表示追加，会将内容追加到已有文件的末尾  </p><h5 id="管道（二次处理）"><a href="#管道（二次处理）" class="headerlink" title="管道（二次处理）|"></a>管道（二次处理）<code>|</code></h5><p>linux允许将一个命令的输出 可以通过管道 作为另一个命令的输入<br>可以理解现实生活中的管子，一头塞东西进去，另一头取出来，这里的<br><code>|</code> 分为左右两端，左端塞东西（写） 右端取东西（读） </p><p>常用的管道命令有：<br>more：分屏显示内容<br>grep：在命令执行结果的基础上查询指定的文本  </p><h3 id="远程管理常用命令"><a href="#远程管理常用命令" class="headerlink" title="远程管理常用命令"></a>远程管理常用命令</h3><h4 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h4><p><code>shutdown 选项 时间</code><br><code>shutdown</code>命令可以安全关闭或者重新启动系统<br><code>shutdown -r 时间</code>  可以重新启动  <code>shutdown -r now</code> 立即重启  </p><h4 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h4><p>网卡<br>网卡是一个专门负责网络通讯的硬件设备<br>IP地址是设置在网卡上的地址信息<br>我们可以把电脑 比作 电话，网卡相当于SIM卡，IP地址相当于电话号码  </p><p>IP地址<br>每台联网的电脑上都有IP地址，是保证电脑之间正常通讯的重要设置<br>注意：每台电脑的IP地址不能相同，否则会出现IP地址冲突，并且没有办法正常通讯<br><img src="/img/linux/14.png" srcset="/img/loading.gif" alt="图14"><br>ifconig可以查看/配置计算机当前的<br><img src="/img/linux/15.png" srcset="/img/loading.gif" alt="图15"></p><p>更方便对应ip地址，可输入：<code>ifconfig | grep inetping</code><br>检测到目标主机是否正常连接<br><code>ping IP</code>地址<br>检测本地网卡工作正常<br><code>ping  127.0.0.1</code><br><code>ping</code> 一般用于检测当前计算机于目标计算机之间的网络是否通畅，数值越大，速度越慢  </p><h4 id="远程登陆和复制文件"><a href="#远程登陆和复制文件" class="headerlink" title="远程登陆和复制文件"></a>远程登陆和复制文件</h4><h5 id="ssh基础（重点）"><a href="#ssh基础（重点）" class="headerlink" title="ssh基础（重点）"></a>ssh基础（重点）</h5><p>在Linux中SSH是非常常用的工具，通过SSH 客户端 我们可以连接到运行了SSH服务器的远程机器上<br>数据传输是加密的，可以防止信息泄露<br>数据传输是压缩的，可以提高传输速度<br>SSH客户端是一种使用Secure Shell（SSH）协议连接到远程计算机的软件程序<br>SSH是目前较可靠，专为远程登录会话和其他网络服务 提供安全性的协议  </p><ol><li><p>域名和端口号<br>域名：由一串用点分隔的名字组成，例如：<code>www.itcast.cn</code>是IP地址的别名，方便用户记忆<br>端口号：通过IP地址可以找到网络上的计算机<br>而通过端口号可以找到计算机上运行的应用程序<br>SSH服务器的默认端口号是22，如果是默认端口号，在连接的时候可以省略<br>常见服务端口号如下：<code>22 80 443</code></p></li><li><p>ssh客户端的简单使用<br><code>ssh [-p port] user@remote</code><br>user 是远程机器上的用户名。如果不指定的话默认为当前用户<br>remote 是远程机器的地址，可以是IP/域名，或者是后面会提到的别名<br>port 是SSH Server监听的端口，如果不指定，就默认为22<br>使用exit退出当前用户的登录<br>注意：ssh这个终端命令只能在Linux或者Unix系统下使用<br>如果在Windows系统中，可以安装Putty或者Xshell客户端软件即可<br><img src="/img/linux/16.png" srcset="/img/loading.gif" alt="图16"></p></li></ol><h5 id="scp（掌握）"><a href="#scp（掌握）" class="headerlink" title="scp（掌握）"></a>scp（掌握）</h5><p> scp就是secure copy，是一个在Linux下用来进行远程拷贝文件的命令（跟在ip后面冒号不可省略）<br>它的地址格式与ssh基本相同，需要注意的是，在指定端口时用的是大写的-P而不是小写的<br><img src="/img/linux/17.png" srcset="/img/loading.gif" alt="图17"><br>如果在Windows系统中，可以安装Putty，使用pscp命令行工具或者安装Filezilla使用FTP进行文件传<br><img src="/img/linux/18.png" srcset="/img/loading.gif" alt="图18"></p><h5 id="SSH高级（知道）"><a href="#SSH高级（知道）" class="headerlink" title="SSH高级（知道）"></a>SSH高级（知道）</h5><ol><li>免密码登陆<br>步骤：<br>配置公钥<br>执行ssh-keygen即可生成SSH钥匙，一路回车即可<br>上传公钥到服务器<br>执行ssh-copy-id -P port ﻿user@remote,可以让远程服务器记住我们的公钥<br><img src="/img/linux/19.png" srcset="/img/loading.gif" alt="图19"></li></ol><p>2）配置别名<br>每次都输入ssh -P port user@remote,时间久了会觉得很麻烦，特别是当user，port和remote都要输入，而且还不好记忆<br>而配置别名可以让我们进一步偷懒，比如用ssh mac来替代上面一长串，那么就在~/.ssh/config里面追加以下内容<br><pre><code class="hljs routeros">Host myserverHostName ip地址User ithrimaport 22</code></pre><br>保存之后，即可用ssh mac 实现远程登录了，scp同样可以使用  </p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git&amp;Github</title>
    <link href="/2019/11/15/%E5%A5%BD%E7%94%A8%E7%9A%84git/"/>
    <url>/2019/11/15/%E5%A5%BD%E7%94%A8%E7%9A%84git/</url>
    
    <content type="html"><![CDATA[<h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><ul><li><p>初始化一个Git仓库，使用<code>git init</code>命令。<br>添加文件到Git仓库，分两步：  </p><ol><li>使用命令git add <file>，注意，可反复多次使用，添加多个文件；</li><li>使用命令git commit -m <message>，完成。</li></ol></li><li><p>要随时掌握工作区的状态，使用<code>git status</code>命令。<br>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p></li><li><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。<br>(HEAD^是指的上一个版本HEAD^^指的是上上个版本)</p></li><li><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。  </p></li><li><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。<br><img src="/img/git/1.png" srcset="/img/loading.gif" alt="分支示意图"></p></li><li><p>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到commit中 </p></li><li><p>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。    </p></li><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。      </li><li><p>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。  </p></li><li><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容.  </p></li><li><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 </p></li></ul><h3 id="关联远程库推送"><a href="#关联远程库推送" class="headerlink" title="关联远程库推送"></a>关联远程库推送</h3><ul><li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；  </li><li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；  </li><li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；  </li></ul><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h3 id="克隆远程库项目"><a href="#克隆远程库项目" class="headerlink" title="克隆远程库项目"></a>克隆远程库项目</h3><ul><li>从远程库克隆<br><code>git clone git@github.com:Mango/gitskills.git</code></li><li>要克隆一个仓库，首先必须知道仓库的地址然后使用<code>git clone  git@</code>  </li></ul><h3 id="分支的使用"><a href="#分支的使用" class="headerlink" title="分支的使用"></a>分支的使用</h3><p>Git鼓励大量使用分支：</p><ul><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch &lt;name&gt;</code></li><li>切换分支：<code>git checkout &lt;name&gt;或者git switch &lt;name&gt;</code></li><li>创建+切换分支：<code>git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;</code></li><li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li><li>删除分支：<code>git branch -d &lt;name&gt;</code>  </li></ul><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。  </p><ul><li>用<code>git log --graph</code>命令可以看到分支合并图。</li></ul><p>在实际开发中，我们应该按照几个基本原则进行分支管理：<br>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；<br>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。  </p><ul><li>Git分支十分强大，在团队开发中应该充分应用。<br>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。  </li><li><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；<br>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。  </p></li><li><p>开发一个新feature，最好新建一个分支；<br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p></li><li><p>多人协作的工作模式通常是这样：<br>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；<br>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；<br>如果合并有冲突，则解决冲突，并在本地提交；<br>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！<br>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。<br>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p></li><li><p>查看远程库信息，使用<code>git remote -v</code>；<br>本地新建的分支如果不推送到远程，对其他人就是不可见的；  </p></li><li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；  </p></li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；    </li><li>建立本地分支和远程分支的关联，使用<code>git branch   --set-upstream branch-name origin/branch-name</code>；<br>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。  </li></ul><p>rebase操作可以把本地未push的分叉提交历史整理成直线；<br>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 </p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul><li>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起<br>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；<br>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...</code>“可以指定标签信息；<br>命令<code>git tag</code>可以查看所有标签。<br>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字<br>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；<br>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；<br>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；<br>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。 </li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在GitHub上，可以任意Fork开源仓库；<br>自己拥有Fork后的仓库的读写权限；<br>可以推送pull request给官方仓库来贡献代码。</p><p>让Git显示颜色，会让命令输出看起来更醒目：<br><code>git config --global color.ui true</code></p>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VIM的使用</title>
    <link href="/2019/10/08/VIM%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/10/08/VIM%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="光标命令"><a href="#光标命令" class="headerlink" title="光标命令"></a>光标命令</h3><pre><code class="hljs properties"><span class="hljs-attr">h</span> <span class="hljs-string">左移一个字符</span><span class="hljs-attr">l</span> <span class="hljs-string">右移一个字符</span><span class="hljs-attr">j</span> <span class="hljs-string">下移一行</span><span class="hljs-attr">k</span> <span class="hljs-string">上移一行</span><span class="hljs-attr">w</span> <span class="hljs-string">前移一个单词，光标停在下一个单词开头</span><span class="hljs-attr">W</span> <span class="hljs-string">移动下一个单词开头，但忽略一些标点</span><span class="hljs-attr">e</span> <span class="hljs-string">前移一个单词，光标停在下一个单词末尾</span><span class="hljs-attr">E</span> <span class="hljs-string">移动到下一个单词末尾，如果词尾有标点，则移动到标点</span><span class="hljs-attr">b</span> <span class="hljs-string">后移一个单词，光标停在上一个单词开头</span><span class="hljs-attr">B</span> <span class="hljs-string">移动到上一个单词开头，忽略一些标点</span><span class="hljs-meta">(</span> <span class="hljs-string">前移1句</span><span class="hljs-meta">)</span> <span class="hljs-string">后移1句</span><span class="hljs-meta">&#123;</span> <span class="hljs-string">前移1段</span><span class="hljs-meta">&#125;</span> <span class="hljs-string">后移1段​</span></code></pre><h3 id="滚屏命令"><a href="#滚屏命令" class="headerlink" title="滚屏命令"></a>滚屏命令</h3><pre><code class="hljs properties"><span class="hljs-meta">ctrl+f</span> <span class="hljs-string">下翻一屏</span><span class="hljs-meta">ctrl+b</span> <span class="hljs-string">上翻一屏</span><span class="hljs-meta">ctrl+d</span> <span class="hljs-string">下翻半屏</span><span class="hljs-meta">ctrl+u</span> <span class="hljs-string">上翻半屏</span><span class="hljs-meta">ctrl+e</span> <span class="hljs-string">向下滚动一行</span><span class="hljs-meta">ctrl+y</span> <span class="hljs-string">向上滚动一行</span><span class="hljs-meta">n%</span> <span class="hljs-string">到文件n%的位置</span><span class="hljs-attr">zz</span> <span class="hljs-string">将当前行移动到屏幕中央</span><span class="hljs-attr">zt</span> <span class="hljs-string">将当前行移动到屏幕顶端</span><span class="hljs-attr">zb</span> <span class="hljs-string">将当前行移动到屏幕底端​</span></code></pre><h3 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h3><pre><code class="hljs excel">第一部分 基本插入I 在当前行第一个非空字符前插入gI 在当前行第一列插入a 在光标后插入A 在当前行最后插入o 在下面新建一行插入O 在上面新建一行插入第二部分 改写插入c[<span class="hljs-built_in">n</span>]w 改写光标后<span class="hljs-number">1</span>(<span class="hljs-built_in">n</span>)个词c[<span class="hljs-built_in">n</span>]l 改写光标后<span class="hljs-built_in">n</span>个字母,l (vim中光标右移一个字符命令)c[<span class="hljs-built_in">n</span>]h 改写光标前<span class="hljs-built_in">n</span>个字母, h (vim中光标左移一个字符命令)[<span class="hljs-built_in">n</span>]cc 修改当前[<span class="hljs-built_in">n</span>]行[<span class="hljs-built_in">n</span>]s 以输入的文本替代光标之后<span class="hljs-number">1</span>(<span class="hljs-built_in">n</span>)个字符，相当于c[<span class="hljs-built_in">n</span>]l[<span class="hljs-built_in">n</span>]S 删除指定数目的行，并以所输入文本代替之​</code></pre><h3 id="复制命令"><a href="#复制命令" class="headerlink" title="复制命令"></a>复制命令</h3><pre><code class="hljs excel">y 复制在可视模式下选中的文本yy <span class="hljs-built_in">or</span> Y 复制整行文本y[<span class="hljs-built_in">n</span>]w 复制一(<span class="hljs-built_in">n</span>)个词y[<span class="hljs-built_in">n</span>]l 复制光标右边<span class="hljs-number">1</span>(<span class="hljs-built_in">n</span>)个字符y[<span class="hljs-built_in">n</span>]h 复制光标左边<span class="hljs-number">1</span>(<span class="hljs-built_in">n</span>)个字符y$ 从光标当前位置复制到行尾<span class="hljs-symbol">y0</span> 从光标当前位置复制到行首​﻿​</code></pre><h3 id="剪切和粘贴命令"><a href="#剪切和粘贴命令" class="headerlink" title="剪切和粘贴命令"></a>剪切和粘贴命令</h3><pre><code class="hljs excel">[<span class="hljs-built_in">n</span>]x 剪切光标右边<span class="hljs-built_in">n</span>个字符，相当于d[<span class="hljs-built_in">n</span>]l[<span class="hljs-built_in">n</span>]X 剪切光标左边<span class="hljs-built_in">n</span>个字符，相当于d[<span class="hljs-built_in">n</span>]hp 在光标之后粘贴P 在光标之前粘贴​</code></pre><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><pre><code class="hljs excel">d 删除（剪切）在可视模式下选中的文本d$ <span class="hljs-built_in">or</span> D 删除（剪切）当前位置到行尾的内容d[<span class="hljs-built_in">n</span>]w 删除（剪切）<span class="hljs-number">1</span>(<span class="hljs-built_in">n</span>)个单词d[<span class="hljs-built_in">n</span>]l 删除（剪切）光标右边<span class="hljs-number">1</span>(<span class="hljs-built_in">n</span>)个字符d[<span class="hljs-built_in">n</span>]h 删除（剪切）光标左边<span class="hljs-number">1</span>(<span class="hljs-built_in">n</span>)个字符<span class="hljs-symbol">d0</span> 删除（剪切）当前位置到行首的内容[<span class="hljs-built_in">n</span>] dd 删除（剪切）<span class="hljs-number">1</span>(<span class="hljs-built_in">n</span>)行​</code></pre><h3 id="撤销命令"><a href="#撤销命令" class="headerlink" title="撤销命令"></a>撤销命令</h3><pre><code class="hljs properties"><span class="hljs-attr">u</span> <span class="hljs-string">撤销最后执行的命令</span><span class="hljs-attr">U</span> <span class="hljs-string">撤销对整行的修改​</span></code></pre><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><pre><code class="hljs applescript">/<span class="hljs-built_in">word</span> 在后面的文本中查找<span class="hljs-built_in">word</span>?<span class="hljs-built_in">word</span> 在前面的文本中查找<span class="hljs-built_in">word</span>/pattern/+<span class="hljs-built_in">number</span> 将光标停在包含pattern的行后面第<span class="hljs-built_in">number</span>行上/pattern/-<span class="hljs-built_in">number</span> 将光标停在包含pattern的行前面第<span class="hljs-built_in">number</span>行上n 向后查找下一个N 向前查找下一个​</code></pre><h3 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h3><pre><code class="hljs elixir"><span class="hljs-symbol">:s/old/new/g</span> 可以替换 old 为 new替换两行之间出现的每个匹配串，操作如下<span class="hljs-symbol">:</span><span class="hljs-comment">#,#s/old/new/g 其中 #,# 代表的是替换操作的若干行中首尾两行的行号。</span><span class="hljs-symbol">:%s/old/new/g</span> 则是替换整个文件中的每个匹配串。<span class="hljs-symbol">:%s/old/new/gc</span> 会找到整个文件中的每个匹配串，并且对每个匹配串提示是否进行替换。</code></pre><h3 id="排版命令"><a href="#排版命令" class="headerlink" title="排版命令"></a>排版命令</h3><pre><code class="hljs ruby">&lt;&lt; 向左缩进一个shiftwidth<span class="hljs-meta">&gt;&gt;</span> 向右缩进一个shiftwidth<span class="hljs-symbol">:ce</span>(nter) 本行文字居中<span class="hljs-symbol">:le</span>(ft) 本行文字靠左<span class="hljs-symbol">:ri</span>(ght) 本行文字靠右</code></pre><h3 id="命令行中分屏打开多文件"><a href="#命令行中分屏打开多文件" class="headerlink" title="命令行中分屏打开多文件"></a>命令行中分屏打开多文件</h3><pre><code class="hljs css"><span class="hljs-selector-tag">-o</span> 水平分屏<span class="hljs-selector-tag">vim</span> <span class="hljs-selector-tag">-o</span><span class="hljs-selector-attr">[n]</span> <span class="hljs-selector-tag">file1</span> <span class="hljs-selector-attr">[file2 ...]</span><span class="hljs-selector-tag">-O</span> 垂直分屏<span class="hljs-selector-tag">vim</span> <span class="hljs-selector-tag">-O</span><span class="hljs-selector-attr">[n]</span> <span class="hljs-selector-tag">file1</span> <span class="hljs-selector-attr">[file2 ...]</span></code></pre><h3 id="vim中命令模式分屏"><a href="#vim中命令模式分屏" class="headerlink" title="vim中命令模式分屏"></a>vim中命令模式分屏</h3><ol><li>垂直分屏<pre><code class="hljs vim">:<span class="hljs-keyword">vs</span> [<span class="hljs-keyword">file</span>]:<span class="hljs-keyword">vs</span> 将当前文件垂直分屏:<span class="hljs-keyword">vs</span> <span class="hljs-keyword">file</span> 创建新文件并垂直分屏</code></pre></li><li>水平分屏<pre><code class="hljs vim">:<span class="hljs-keyword">sv</span> [<span class="hljs-keyword">file</span>]:<span class="hljs-keyword">sv</span> 将当前文件水平分屏:<span class="hljs-keyword">sv</span> <span class="hljs-keyword">file</span> 创建新文件并水平分屏</code></pre></li></ol><h3 id="分屏屏间光标移动"><a href="#分屏屏间光标移动" class="headerlink" title="分屏屏间光标移动"></a>分屏屏间光标移动</h3><ol><li>分屏间循环移动光标<br><code>ctrl-w ctrl-w</code></li><li>光标移到右边的屏中<br><code>ctrl+w l</code></li><li>光标移到左边的屏中<br><code>ctrl+w h</code></li><li>光标移到上面的屏中<br><code>ctrl+w k</code></li><li>光标移到下边的屏中<br><code>ctrl+w j</code></li><li>光标移到下一个屏中<br><code>ctrl+w w</code></li><li>把光标移到上一个屏中<br><code>ctrl+w p</code></li></ol><h3 id="分屏的移动"><a href="#分屏的移动" class="headerlink" title="分屏的移动"></a>分屏的移动</h3><p>四个键位同上相比均换成了大写</p><ol><li>把当前分屏移动到最左边<br><code>ctrl+w H</code></li><li>把当前分屏移动到上面并扩展到整屏的宽度<br><code>ctrl+w K</code></li><li>把当前分屏移动到最下边<br><code>ctrl+w J</code> </li><li>把当前分屏移动到最右边<br><code>ctrl+w L</code> </li></ol><h3 id="关闭分屏"><a href="#关闭分屏" class="headerlink" title="关闭分屏"></a>关闭分屏</h3><ol><li>关闭当前子屏<br><code>ctrl+wc</code></li><li>关闭当前子屏，若为最后一个，则退出vim<br><code>ctrl+w q</code> </li><li>hide<br><code>:hide 关闭当前窗口</code> </li><li>only<br><code>:only 仅保持此窗口开启</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown的基本语法</title>
    <link href="/2019/06/08/markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2019/06/08/markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code class="hljs clean">#一级标题  ##二级标题  ###三级标题  ####四级标题  #####五级标题  ######六级标题</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>1     <code>* 1</code></li><li>2     <code>* 2</code></li><li>3     <code>* 3</code></li></ul><ol><li>1.</li><li>2.</li><li>3.</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>只需要在文本前加入&gt;即可</p><blockquote><p>这里是引用 </p></blockquote><p>注意符合和文本间要空格</p><h2 id="插入图片和链接"><a href="#插入图片和链接" class="headerlink" title="插入图片和链接"></a>插入图片和链接</h2><p>插入链接 [超链接名] (链接地址 “超链接title”)  </p><p>插入图片<br>! [图片alt] (图片地址 ‘’图片title’’)<br>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>生成表格<br><pre><code class="hljs ruby"><span class="hljs-params">| Tables        |</span> Are           <span class="hljs-params">| Cool  |</span>  <span class="hljs-params">| ------------- |</span><span class="hljs-symbol">:-------------</span><span class="hljs-symbol">:|</span> -----<span class="hljs-symbol">:|</span>   <span class="hljs-params">| col 3 is      |</span> right-aligned <span class="hljs-params">| $1600 |</span>  <span class="hljs-params">| col 2 is      |</span> centered      <span class="hljs-params">|   $12 |</span>  <span class="hljs-params">| zebra stripes |</span> are neat      <span class="hljs-params">|    $1 |</span></code></pre></p><div class="table-container"><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table></div><p>第二行分割表头和内容。<br><code>-</code>有一个就行，为了对齐，多加了几个<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>原生的语法两边都要用 | 包起来</p><h2 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h2><p>用两个<code>*</code>包起来<br><strong>这是加粗的文字</strong><br>用一个<code>*</code>包起来<br><em>这是倾斜的文字</em><br>用<strong><em>包起来  </em></strong>这是斜体加粗的文字<em>*</em><br>用～包起来<br><del>这是加删除线的文字</del></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>单行代码之间用反引号包起来<br>代码块两边分别用三个反引号包起来，且两边的反引号单独占一行<br><code>``` </code><br>  代码…<br>  代码…<br>  代码…<br><code>``` </code></p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>只需要三个<em>*</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
